{
	"topic":"LinkedList",
	"intro":"<div><h2>    Linked List Data Structure</h2><p>    A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations. The elements in a linked list are linked using pointers</p><p>    In simple words, a linked list consists of nodes where each node contains a data field and a reference(link) to the next node in the list.</p><h3>    Topics</h3><ul><li>    Singly Linked List</li>    <li>    Circular Linked List    </li>    <li>        Doubly Linked List    </li></ul></div>",
	"topics":[
			{
		"topic":"Singly LinkedList",
		"content":"<div><h2>    Singly Linked List</h2> <h3>    Representations of linked list . </h3><div style="background-color: black;width: 60%;"><code style="color:orangered;">  // Linked List Class <br>class LinkedList <br>{ <br> Node head;  // head of list <br><br>/* Node Class */<br>class Node <br>{ <br> int data;<br>  Node next; <br><br> // Constructor to create a new node<br> Node(int d) {data = d; next = null; } <br>} <br>}<br></code></div><h3>    Insertion of Node</h3><ol>    <li>    <h4>    Add a node at the front:    </h4>    <p>    The new node is always added before the head of the given Linked List. And newly added node becomes the new head of the Linked List. For example if the given Linked List is 10->15->20->25 and we add an item 5 at the front, then the Linked List becomes 5->10->15->20->25. Let us call the function that adds at the front of the list is push(). The push() must receive a pointer to the head pointer, because push must change the head pointer to point to the new node    </p>    <div style="background-color: black;width: 60%;"><code style="color:orangered;">    /* This function is in LinkedList class. Inserts a <br>new Node at front of the list. This method is  <br>defined inside LinkedList class shown above */<br>public void push(int new_data) <br>{ <br>/* 1 & 2: Allocate the Node &<br>    Put in the data*/<br>Node new_node = new Node(new_data);<br><br> /* 3. Make next of new Node as head */<br>new_node.next = head; <br><br>/* 4. Move the head to point to new Node */<br>head = new_node; <br>}     </code></div>    <p>        Time complexity of push() is O(1) as it does constant amount of work.    </p></li><li>    <h4>        Add a node at the end:    </h4>   <p>    The new node is always added after the last node of the given Linked List. For example if the given Linked List is 5->10->15->20->25 and we add an item 30 at the end, then the Linked List becomes 5->10->15->20->25->30.<br>Since a Linked List is typically represented by the head of it, we have to traverse the list till end and then change the next of last node to new node.    </p>    <div style="background-color: black;width: 60%;"><code style="color:orangered;">    /* Appends a new node at the end.  This method is  <br>defined inside LinkedList class shown above */<br>public void append(int new_data) <br>{ <br>/* 1. Allocate the Node &<br>    2. Put in the data <br>   3. Set next as null */<br>Node new_node = new Node(new_data);<br><br> /* 4. If the Linked List is empty, then make the<br>        new node as head */<br>if (head == null) <br>{ <br>    head = new Node(new_data);<br>     return; <br>} <br><br>/* 4. This new node is going to be the last node, so<br>      make next of it as null */<br>new_node.next = null; <br><br>/* 5. Else traverse till the last node */<br>Node last = head;  <br>while (last.next != null)<br>     last = last.next; <br><br>/* 6. Change the next of last node */<br>last.next = new_node; <br>return; <br>}     </code></div>   <p>    Time complexity of append is O(n) where n is the number of nodes in linked list. Since there is a loop from head to end, the function does O(n) work.<br>This method can also be optimized to work in O(1) by keeping an extra pointer to tail of linked list/        </p>    </li>    <li>    <h4>        Add a node after a given node:    </h4>    <div style="background-color: black;width: 60%;"><code style="color:orangered;">    /* This function is in LinkedList class. <br> Inserts a new node after the given prev_node. This method is<br>   defined inside LinkedList class shown above */<br>public void insertAfter(Node prev_node, int new_data)<br>{ <br> /* 1. Check if the given Node is null */<br>if (prev_node == null) <br>{ <br>    System.out.println(\"The given previous node cannot be null\"); <br>    return; <br>} <br><br>/* 2. Allocate the Node &<br>    3. Put in the data*/<br>Node new_node = new Node(new_data);<br><br>  /* 4. Make next of new Node as next of prev_node */<br> new_node.next = prev_node.next; <br><br> /* 5. make next of prev_node as new_node */<br> prev_node.next = new_node; <br>}     </code></div>    <p>        Time complexity of insertAfter() is O(1) as it does constant amount of work.    </p>    </li></ol><h3>    Deleting a node</h3><p>    Let us formulate the problem statement to understand the deletion process. Given a ‘key’, delete the first occurrence of this key in linked list.<br>    To delete a node from linked list, we need to do following steps.</p><ol>    <li>        Find previous node of the node to be deleted.    </li>    <li>        Change the next of previous node.    </li>   <li>    Free memory for the node to be deleted. </li></ol> <div style="background-color: black;width: 60%;"> <code style="color:orangered;"> /* Given a key, deletes the first occurrence of key in linked list */<br> void deleteNode(int key) <br>{ <br>    // Store head node <br>    Node temp = head, prev = null;<br><br>     // If head node itself holds the key to be deleted <br>    if (temp != null && temp.data == key) <br>    { <br>    head = temp.next; // Changed head<br>     return; <br>    } <br><br>  // Search for the key to be deleted, keep track of the <br>    // previous node as we need to change temp.next <br>   while (temp != null && temp.data != key) <br>    { <br>        prev = temp; <br>        temp = temp.next;<br>     }     <br>  // If key was not present in linked list<br>     if (temp == null) return; <br><br>  // Unlink the node from linked list<br>     prev.next = temp.next; <br>    } <br></code></div></div>"
	},
			{
		"topic":"Circular Singly LinkedList",
		"content":"<div> <h2>    Circular Singly Linked List</h2><p>    <b>Why Circular?</b> In a singly linked list, for accessing any node of linked list, we start traversing from the first node. If we are at any node in the middle of the list, then it is not possible to access nodes that precede the given node. This problem can be solved by slightly altering the structure of singly linked list. In a singly linked list, next part (pointer to next node) is NULL, if we utilize this link to point to the first node then we can reach preceding nodes</p><h3>    Implementation</h3> <p>    To implement a circular singly linked list, we take an external pointer that points to the last node of the list. If we have a pointer last pointing to the last node, then last -> next will point to the first node.<br>    The ponter last points to node Z and last -> next points to node<br>    Following is a complete program that uses all of the above methods to create a circular singly linked list.</p><div style="background-color: black;width: 60%;"><code style="color:orangered;">    class Tech<br>  { <br><br>static class Node<br> { <br>  int data; <br> Node next; <br>}; <br><br>static Node addToEmpty(Node last, int data) <br>{ <br> // This function is only for empty list<br>  if (last != null) <br>return last; <br><br> // Creating a node dynamically. <br>Node temp = new Node(); <br><br>// Assigning the data. <br>temp.data = data; <br>last = temp; <br><br> // Creating the link.<br>  last.next = last; <br><br> return last; <br>} <br><br>static Node addBegin(Node last, int data)<br> { <br>if (last == null)<br>     return addToEmpty(last, data);<br><br>  Node temp = new Node(); <br><br> temp.data = data; <br> temp.next = last.next;<br>  last.next = temp; <br><br> return last; <br>} <br><br>static Node addEnd(Node last, int data)<br> { <br>if (last == null) <br>    return addToEmpty(last, data); <br><br> Node temp = new Node(); <br><br> temp.data = data; <br> temp.next = last.next;<br>  last.next = temp; <br>last = temp; <br><br> return last; <br>} <br><br>static Node addAfter(Node last, int data, int item)<br> { <br>if (last == null) <br>   return null; <br><br>Node temp, p; <br>p = last.next; <br>do<br>{ <br>   if (p.data == item) <br>    { <br>    temp = new Node();<br>     temp.data = data; <br>    temp.next = p.next; <br>    p.next = temp; <br><br> if (p == last) <br>        last = temp; <br>    return last; <br>    } <br>    p = p.next;<br>  } while(p != last.next);<br><br> System.out.println(item + \" not present in the list.\"); <br> return last; <br><br>} <br><br>static void traverse(Node last)<br>{ <br>Node p;<br><br> // If list is empty, return.<br> if (last == null) <br> { <br>    System.out.println(\"List is empty.\");<br>     return; <br>} <br><br>// Pointing to first Node of the list. <br>p = last.next; <br><br> // Traversing the list.<br>  do<br>{ <br>    System.out.print(p.data + \" \");<br>     p = p.next; <br> } <br> while(p != last.next);<br><br> } <br><br>// Driven code<br> public static void main(String[] args) <br>{ <br> Node last = null;<br><br>  last = addToEmpty(last, 6);<br>  last = addBegin(last, 4); <br> last = addBegin(last, 2); <br> last = addEnd(last, 8); <br> last = addEnd(last, 12); <br> last = addAfter(last, 10, 8);<br><br>  traverse(last); <br>} <br>} </code></div><h3>    Deletion from Circular Linked List</h3><ul><li>    If the list is not empty then we define two pointers curr and prev and initialize the pointer curr with the head node.</li><li>    Traverse the list using curr to find the node to be deleted and before moving curr to next node, everytime set prev = curr.</li><li>    If the node is found, check if it is the only node in the list. If yes, set head = NULL and free(curr).</li><li>    If the list has more than one node, check if it is the first node of the list. Condition to check this( curr == head). If yes, then move prev until it reaches the last node. After prev reaches the last node, set head = head -> next and prev -> next = head. Delete curr.</li><li>    If curr is not first node, we check if it is the last node in the list. Condition to check this is (curr -> next == head).</li><li>    If curr is the last node. Set prev -> next = head and delete the node curr by free(curr).</li><li>   If the node to be deleted is neither the first node nor the last node, then set prev -> next = temp -> next and delete curr. </li></ul> <div style="background-color: black;width: 60%;"> <code style="color:orangered;"> /* Function to delete a given node from the list */<br>static Node deleteNode(Node head, int key) <br>{ <br>    if (head == null) <br>    return null; <br><br>    // Find the required node<br>    Node curr = head, prev = new Node();<br>     while (curr.data != key) { <br>    if (curr.next == head) { <br>    System.out.printf(\"\nGiven node is not found\"   + \" in the list!!!\");<br>      break; <br>     } <br><br>    prev = curr;<br>     curr = curr.next;<br>    } <br><br>    // Check if node is only node <br>    if (curr.next == head) { <br>    head = null; <br>     return head; <br>    } <br><br>    // If more than one node, check if <br>    // it is first node <br>    if (curr == head) { <br>    prev = head; <br>    while (prev.next != head) <br>    prev = prev.next; <br>        head = curr.next; <br>        prev.next = head; <br>    } <br><br>  // check if node is last node<br>     else if (curr.next == head) { <br>    prev.next = head; <br>    } <br>    else {<br>         prev.next = curr.next; <br>    } <br>    return head;<br>     } </code></div></div>"
	},
	{
		"topic":"Doubly LinkedList",
		"content":"<div> <h2>    Doubly Linked List </h2><p>    A Doubly Linked List (DLL) contains an extra pointer, typically called previous pointer, together with next pointer and data which are there in singly linked list. </p><h3>    Advantages over singly linked list </h3><ol> <li>    A DLL can be traversed in both forward and backward direction.</li><li>    The delete operation in DLL is more efficient if pointer to the node to be deleted is given.   </li>   <li>    We can quickly insert a new node before a given node.In singly linked list, to delete a node, pointer to the previous node is needed. To get this previous node, sometimes the list is traversed. In DLL, we can get the previous node using previous pointer.    </li></ol><h3>    Disadvantages over singly linked list</h3><ol> <li>    Every node of DLL Require extra space for an previous pointer. It is possible to implement DLL with single pointer though (See this and this). </li> <li>    All operations require an extra pointer previous to be maintained. For example, in insertion, we need to modify previous pointers together with next pointers. For example in following functions for insertions at different positions, we need 1 or 2 extra steps to set previous pointer.    </li></ol><h3>    Insertion :</h3> <div style="background-color: black;width: 60%;"> <code style="color:orangered;">   // A complete working Java program to demonstrate all <br><br>// Class for Doubly Linked List <br>public class DLL { <br>Node head; // head of list <br><br>/* Doubly Linked list Node*/<br>class Node { <br>    int data; <br>    Node prev; <br>    Node next; <br><br>  // Constructor to create a new node<br>     // next and prev is by default initialized as null<br>     Node(int d) { data = d; } <br>} <br><br>// Adding a node at the front of the list <br> public void push(int new_data) <br>{ <br>   /* 1. allocate node<br>     * 2. put in the data */<br>   Node new_Node = new Node(new_data); <br><br>    /* 3. Make next of new node as head and previous as NULL */<br>    new_Node.next = head; <br>   new_Node.prev = null; <br><br>    /* 4. change prev of head node to new node */<br>    if (head != null) <br>    head.prev = new_Node;<br><br>     /* 5. move the head to point to the new node */<br>    head = new_Node; <br>} <br><br>/* Given a node as prev_node, insert a new node after the given node */<br>public void InsertAfter(Node prev_Node, int new_data) <br> { <br><br> /*1. check if the given prev_node is NULL */<br>if (prev_Node == null) { <br>    System.out.println(\"The given previous node cannot be NULL \"); <br>    return; <br>  } <br><br> /* 2. allocate node <br>   * 3. put in the data */<br>  Node new_node = new Node(new_data);<br>  /* 4. Make next of new node as next of prev_node */<br> new_node.next = prev_Node.next; <br><br>  /* 5. Make the next of prev_node as new_node */<br>  prev_Node.next = new_node; <br><br>  /* 6. Make prev_node as previous of new_node */<br>  new_node.prev = prev_Node; <br><br> /* 7. Change previous of new_node's next node */<br> if (new_node.next != null) <br>    new_node.next.prev = new_node;<br> } <br><br>// Add a node at the end of the list <br> void append(int new_data) <br>{ <br>   /* 1. allocate node*/<br>     * 2. put in the data */<br>   Node new_node = new Node(new_data);<br><br>    Node last = head; /* used in step 5*/<br>    /* 3. This new node is going to be the last node, so<br>     * make next of it as NULL*/<br>   new_node.next = null; <br><br> /* 4. If the Linked List is empty, then make the new<br>  * node as head */<br> if (head == null) { <br>    new_node.prev = null;<br>     head = new_node; <br>    return; <br>} <br> /* 5. Else traverse till the last node */<br> while (last.next != null) <br>   last = last.next; <br><br>    /* 6. Change the next of last node */<br>    last.next = new_node; <br>    /* 7. Make last node as previous of new node */<br>    new_node.prev = last; <br>} <br><br>// This function prints contents of linked list starting from the given node<br>  public void printlist(Node node) <br> { <br>    Node last = null;<br>     System.out.println(\"Traversal in forward Direction\");<br>     while (node != null) { <br>    System.out.print(node.data + \" \");<br>     last = node; <br>    node = node.next;<br>    } <br>    System.out.println();<br>     System.out.println(\"Traversal in reverse direction\");<br>     while (last != null) { <br>    System.out.print(last.data + \" \");<br>    last = last.prev; <br>   } <br>} <br><br> /* Drier program to test above functions*/<br> public static void main(String[] args) <br>{ <br>   /* Start with the empty list */<br>    DLL dll = new DLL(); <br><br>  // Insert 6. So linked list becomes 6->NULL<br>     dll.append(6); <br><br> // Insert 7 at the beginning. So linked list becomes 7->6->NULL<br>     dll.push(7); <br><br> // Insert 1 at the beginning. So linked list becomes 1->7->6->NULL<br>    dll.push(1); <br><br>  // Insert 4 at the end. So linked list becomes 1->7->6->4->NULL<br>    dll.append(4); <br><br>   // Insert 8, after 7. So linked list becomes 1->7->8->6->4->NULL <br>   dll.InsertAfter(dll.head.next, 8); <br><br>   System.out.println(\"Created DLL is: \"); <br>    dll.printlist(dll.head); <br> } } </code></div><h3>    Deletion :</h3> <div style="background-color: black;width: 60%;"><code style="color:orangered;">    // Function to delete a node in a Doubly Linked List. <br>// head_ref --> pointer to head node pointer. <br>// del --> data of node to be deleted. <br>void deleteNode(Node head_ref, Node del) <br>{ <br><br>    // Base case<br>     if (head == null || del == null) { <br>    return; <br>    } <br><br>    // If node to be deleted is head node<br>     if (head == del) { <br>    head = del.next; <br>    } <br><br>    // Change next only if node to be deleted <br>    // is NOT the last node <br>   if (del.next != null) { <br>    del.next.prev = del.prev;<br>     } <br><br>    // Change prev only if node to be deleted<br>     // is NOT the first node <br>   if (del.prev != null) { <br>        del.prev.next = del.next;<br>     } <br><br>    // Finally, free the memory occupied by del <br>    return; <br> } </code></div></div>"
	}
		]
}
{
	"topic":"Collections in Java",
	"intro":"<div><h2>    Collections </h2> <p>    A Collection is a group of individual objects represented as a single unit. Java provides Collection Framework which defines several classes and interfaces to represent a group of objects as a single unit.<br>The Collection interface (<b>java.util.Collection</b>) and Map interface (<b>java.util.Map</b>) are the two main “root” interfaces of Java collection classes. </p> <h3>    Need for Collection Framework :</h3><p>    Before Collection Framework (or before JDK 1.2) was introduced, the standard methods for grouping Java objects (or collections) were Arrays or Vectors or Hashtables. All of these collections had no common interface.<br>Accessing elements of these Data Structures was a hassle as each had a different method (and syntax) for accessing its members: </p> <p>    It was very difficult for programmers to write algorithms that can work for all kinds of Collections. Another drawback being that most of the ‘Vector’ methods are final, meaning we cannot extend the ’Vector’ class to implement a similar kind of Collection.  <br><br> <b>   Java developers decided to come up with a common interface to deal with the above mentioned problems and introduced the Collection Framework in JDK 1.2.   </b>    Both legacy Vectors and Hashtables were modified to conform to the Collection Framework.</p><h3>    Advantages of Collection Framework:</h3> <ol> <li>    Consistent API : The API has a basic set of interfaces like Collection, Set, List, or Map. All classes (ArrayList, LinkedList, Vector, etc) that implement these interfaces have some common set of methods.</li><li>    Reduces programming effort: A programmer doesn’t have to worry about the design of Collection, and he can focus on its best use in his program.</li><li>    Increases program speed and quality: Increases performance by providing high-performance implementations of useful data structures and algorithms.  </li></ol></div>",
	"topics":[
			{
		"topic":"ArrayList",
		"content":"<h2>ArrayList</h2><div styles=\"width:1250px\"><p>ArrayList is a part of collection framework and is present in java.util package. It provides us dynamic arrays in Java. Though, it may be slower than standard arrays but can be helpful in programs where lots of manipulation in the array is needed.</p><ul><li>ArrayList inherits AbstractList class and implements List interface.</li> <li>ArrayList is initialized by a size, however the size can increase if collection grows or shrunk if objects are removed from the collection.</li> <li>Java ArrayList allows us to randomly access the list.</li> <li>ArrayList can not be used for primitive types, like int, char, etc. We need a wrapper class for such cases (see this for details).</li> <li>ArrayList in Java can be seen as similar to vector in C++.</li></ul><p>Now primarily the Java ArrayList can constitute of both Constructors and Methods. Below mentioned is a list of few constructors and methods along with there use and functions.</p><h3>Constructors in Java ArrayList:</h3><ol> <li>ArrayList(): This constructor is used to build an empty array list</li> <li>ArrayList(Collection c): This constructor is used to build an array list initialized with the elements from collection c</li><li>ArrayList(int capacity): This constructor is used to build an array list with initial capacity being specified</li></ol><br><code><br> // Java program to demonstrate working of ArrayList in Java <br>import java.io.*; <br>import java.util.*; <br> <br>class arraylist <br>{ <br> public static void main(String[] args) throws IOException <br> { <br> // size of ArrayList<br>  int n = 5; <br><br> //declaring ArrayList with initial size n<br>  ArrayList<Integer> arrli = new ArrayList<Integer>(n); <br><br> // Appending the new element at the end of the list<br> for (int i=1; i<=n; i++) <br> arrli.add(i); <br> <br>// Printing elements<br>  System.out.println(arrli);<br> <br> // Remove element at index 3<br>  arrli.remove(3); <br> <br> // Displaying ArrayList after deletion<br>  System.out.println(arrli); <br>// Printing elements one by one<br> for (int i=0; i < arrli.size(); i++) <br> System.out.print(arrli.get(i)+\" \"); <br>} <br>} <br></code><div>"
	},
			{
		"topic":"LinkedList",
		"content":"<h2>LinkedList</h2><p>  Linked List are linear data structures where the elements are not stored in contiguous locations and every element is a separate object with a data part and address part. The elements are linked using pointers and addresses. Each element is known as a node. Due to the dynamicity and ease of insertions and deletions, they are preferred over the arrays. It also has few disadvantages like the nodes cannot be accessed directly instead we need to start from the head and follow through the link to reach to a node we wish to access.</p><p>  To store the elements in a linked list we use a doubly linked list which provides a linear data structure and also used to inherit an abstract class and implement list and deque interfaces.</p><p>  In Java, LinkedList class implements the list interface. The LinkedList class also consists of various constructors and methods like other java collections.</p><h3>  Constructors for Java LinkedList:</h3><ol><li>   LinkedList(): Used to create an empty linked list.  </li>  <li>  LinkedList(Collection C): Used to create a ordered list which contains all the elements of a specified collection, as returned by the collection’s iterator.  </li></ol><code> // Java code for Linked List implementation <br><br>import java.util.*; <br><br>public class Test <br>{ <br>  public static void main(String args[])<br>  { <br>   // Creating object of class linked list<br>    LinkedList<String> object = new LinkedList<String>();<br>  <br>   // Adding elements to the linked list<br>   object.add(\"A\"); <br>  object.add(\"B\"); <br>  object.addLast(\"C\"); <br>  object.addFirst(\"D\"); <br>  object.add(2, \"E\"); <br>  object.add(\"F\"); <br>   object.add(\"G\"); <br>  System.out.println(\"Linked list : \" + object);<br>  <br>  // Removing elements from the linked list <br>  object.remove(\"B\"); <br>  object.remove(3); <br>  object.removeFirst(); <br>   object.removeLast(); <br>  System.out.println(\"Linked list after deletion: \" + object);<br> <br>  // Finding elements in the linked list <br>  boolean status = object.contains(\"E\"); <br><br>  if(status) <br>   System.out.println(\"List contains the element 'E' \"); <br>  else<br>   System.out.println(\"List doesn't contain the element 'E'\"); <br>  // Number of elements in the linked list <br>  int size = object.size(); <br> System.out.println(\"Size of linked list = \" + size); <br><br>  // Get and set elements from linked list <br>  Object element = object.get(2); <br>  System.out.println(\"Element returned by get() : \" + element); <br>  object.set(2, \"Y\");  <br>System.out.println(\"Linked list after change :\" + object); <br> } <br>} <br></code><h2>  Methods for Java LinkedList:</h2><ol> <li>  add​(int index, E element): This method Inserts the specified element at the specified position in this list. </li>  <li>  add​(E e): This method Appends the specified element to the end of this list. </li> <li>   addAll​(Collection c): This method Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection’s iterator. </li> <li>   contains​(Object o): This method returns true if this list contains the specified element. </li> <li>  remove​(int index): This method removes the element at the specified position in this list. </li></ol>"
	},
	{
		"topic":"Queue",
		"content":"<div><h2>    Queue </h2>  <p>    The Queue interface is available in java.util package and extends the Collection interface. The queue collection is used to hold the elements about to be processed and provides various operations like the insertion, removal etc. It is an ordered list of objects with its use limited to insert elements at the end of the list and deleting elements from the start of list i.e. it follows the FIFO or the First-In-First-Out principle. Being an interface the queue needs a concrete class for the declaration and the most common classes are the PriorityQueue and LinkedList in Java.It is to be noted that both the implementations are not thread safe. PriorityBlockingQueue is one alternative implementation if thread safe implementation is needed. Few important characteristics of Queue are: </p><ul>    <li>        The Queue is used to insert elements at the end of the queue and removes from the beginning of the queue. It follows FIFO concept.    </li>    <li>        The Java Queue supports all methods of Collection interface including insertion, deletion etc.    </li>    <li>        LinkedList, ArrayBlockingQueue and PriorityQueue are the most frequently used implementations.    </li>    <li>        If any null operation is performed on BlockingQueues, NullPointerException is thrown.    </li>    <li>        BlockingQueues have thread-safe implementations.    </li>    <li>        The Queues which are available in java.util package are Unbounded Queues    </li>    <li>        The Queues which are available in java.util.concurrent package are the Bounded Queues.    </li>    <li>        All Queues except the Deques supports insertion and removal at the tail and head of the queue respectively. The Deques support element insertion and removal at both ends.    </li> </ul> <h3>     Methods in Queue: </h3> <ol>    <li>        <b>add()</b>- This method is used to add elements at the tail of queue. More specifically, at the last of linked-list if it is used, or according to the priority in case of priority queue implementation.    </li>    <li>        <b>peek()</b>-This method is used to view the head of queue without removing it. It returns Null if the queue is empty.     </li>    <li>        <b>elements()</b>-This method is similar to peek(). It throws NoSuchElementException when the queue is empty.    </li>    <li>        <b>remove()</b>- This method removes and returns the head of the queue. It throws NoSuchElementException when the queue is empty.    </li>    <li>        <b>poll()</b>- This method removes and returns the head of the queue. It returns null if the queue is empty.    </li>    <li>        <b>size()</b>- This method return the no. of elements in the queue.     </li> </ol> <p>     Below is a simple Java program to demonstrate these methods: </p>  <code>// Java orogram to demonstrate working of Queue <br>// interface in Java <br>import java.util.LinkedList;<br> import java.util.Queue; <br><br>public class QueueExample <br>{ <br>public static void main(String[] args)<br> { <br> Queue<Integer> q = new LinkedList<>();<br><br>  // Adds elements {0, 1, 2, 3, 4} to queue <br> for (int i=0; i<5; i++) <br>  q.add(i); <br><br> // Display contents of the queue.<br>  System.out.println(\"Elements of queue-\"+q); <br><br>  // To remove the head of queue. <br> int removedele = q.remove(); <br> System.out.println(\"removed element-\" + removedele);<br><br>  System.out.println(q); <br><br> // To view the head of queue<br>  int head = q.peek(); <br> System.out.println(\"head of queue-\" + head);<br><br>  // Rest all methods of collection interface, <br> // Like size and contains can be used with this <br> // implementation. <br>  int size = q.size(); <br>  System.out.println(\"Size of queue-\" + size); <br>} <br>} <br> </code></div>"
	},
	{
		"topic":"Stack",
		"content":"<div><h2>    Stack</h2><p>   Java Collection framework provides a Stack class which models and implements Stack data structure. The class is based on the basic principle of last-in-first-out. In addition to the basic push and pop operations, the class provides three more functions of empty, search and peek. The class can also be said to extend Vector and treats the class as a stack with the five mentioned functions. The class can also be referred to as the subclass of Vector.<br>    The class supports one default constructor <b>Stack()</b> which is used to create an empty stack.<br>    Below program shows few basic operations provided by the Stack class:</p><code>    <br>// Java code for stack implementation <br><br>import java.io.*; <br>import java.util.*; <br><br>class Test <br>{    <br>// Pushing element on the top of the stack<br> static void stack_push(Stack<Integer> stack) <br>{ <br>    for(int i = 0; i < 5; i++) <br>    { <br>        stack.push(i);<br>     } <br>} <br><br>// Popping element from the top of the stack<br> static void stack_pop(Stack<Integer> stack) <br>{ <br>    System.out.println(\"Pop :\");<br><br>   for(int i = 0; i < 5; i++) <br>    { <br>        Integer y = (Integer) stack.pop();<br>         System.out.println(y); <br>    } <br>} <br><br>// Displaying element on the top of the stack <br>static void stack_peek(Stack<Integer> stack) <br>{ <br>    Integer element = (Integer) stack.peek(); <br>    System.out.println(\"Element on stack top : \" + element); <br> } <br><br> // Searching element in the stack <br>static void stack_search(Stack<Integer> stack, int element) <br>{ <br>    Integer pos = (Integer) stack.search(element); <br><br>  if(pos == -1) <br>        System.out.println(\"Element not found\"); <br>    else<br>    System.out.println(\"Element is found at position \" + pos);<br> } <br><br><br>public static void main (String[] args)<br> { <br>    Stack<Integer> stack = new Stack<Integer>(); <br><br>  stack_push(stack); <br>    stack_pop(stack); <br>    stack_push(stack); <br>    stack_peek(stack); <br>    stack_search(stack, 2); <br>    stack_search(stack, 6); <br>} <br>} <br></code><h3>    Methods in Stack </h3><ol>    <li>    <b>Object push()(Object element) :</b> Pushes an element on the top of the stack.    </li>    <li>    <b>Object pop()</b> : Removes and returns the top element of the stack. An ‘EmptyStackException’ exception is thrown if we call pop() when the invoking stack is empty.    </li>    <li>    <b>Object peek()</b> : Returns the element on the top of the stack, but does not remove it.    </li>    <li>    <b>boolean empty()</b> : It returns true if nothing is on the top of the stack. Else, returns false.    </li>    <li>        <b>int search(Object element)</b> : It determines whether an object exists in the stack. If the element is found, it returns the position of the element from the top of the stack. Else, it returns -1.    </li> </ol></div>"
	}
		]
}